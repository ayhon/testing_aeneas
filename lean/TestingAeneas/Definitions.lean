-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [testing_aeneas]
import Aeneas
open Aeneas.Std
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace testing_aeneas

/- [testing_aeneas::Tree]
   Source: 'src/lib.rs', lines 1:0-4:1 -/
inductive Tree (T : Type) where
| Leaf : T → Tree T
| Branch : Tree T → Tree T → Tree T

/- [testing_aeneas::{testing_aeneas::Tree<T>}::branch]:
   Source: 'src/lib.rs', lines 7:4-13:5 -/
def Tree.branch
  {T : Type} (left : Tree T) (right : Tree T) : Result (Tree T) :=
  Result.ok (Tree.Branch left right)

/- [testing_aeneas::{testing_aeneas::Tree<T>}::rev]:
   Source: 'src/lib.rs', lines 15:4-20:5 -/
divergent def Tree.rev {T : Type} (self : Tree T) : Result (Tree T) :=
  match self with
  | Tree.Leaf _ => Result.ok self
  | Tree.Branch left right =>
    do
    let t ← Tree.rev right
    let t1 ← Tree.rev left
    Tree.branch t t1

/- [testing_aeneas::{testing_aeneas::Tree<T>}::lenght]:
   Source: 'src/lib.rs', lines 22:4-27:5 -/
divergent def Tree.lenght {T : Type} (self : Tree T) : Result Usize :=
  match self with
  | Tree.Leaf _ => Result.ok 1#usize
  | Tree.Branch left right =>
    do
    let i ← Tree.lenght left
    let i1 ← 1#usize + i
    let i2 ← Tree.lenght right
    i1 + i2

/- [testing_aeneas::BinTree]
   Source: 'src/lib.rs', lines 30:0-37:1 -/
inductive BinTree (T : Type) where
| Nil : BinTree T
| Node : T → BinTree T → BinTree T → BinTree T

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::nil]:
   Source: 'src/lib.rs', lines 41:4-41:49 -/
def BinTree.nil (T : Type) : Result (BinTree T) :=
  Result.ok BinTree.Nil

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::insert]:
   Source: 'src/lib.rs', lines 42:4-52:5 -/
divergent def BinTree.insert
  {T : Type} (self : BinTree T) (value : T) : Result (BinTree T) :=
  match self with
  | BinTree.Nil =>
    do
    let bt ← BinTree.nil T
    let bt1 ← BinTree.nil T
    Result.ok (BinTree.Node value bt bt1)
  | BinTree.Node t bt right =>
    do
    let right1 ← BinTree.insert right value
    Result.ok (BinTree.Node t bt right1)

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::size]:
   Source: 'src/lib.rs', lines 53:4-58:5 -/
divergent def BinTree.size {T : Type} (self : BinTree T) : Result U32 :=
  match self with
  | BinTree.Nil => Result.ok 0#u32
  | BinTree.Node _ left right =>
    do
    let i ← BinTree.size left
    let i1 ← 1#u32 + i
    let i2 ← BinTree.size right
    i1 + i2

/- Trait declaration: [core::cmp::PartialEq]
   Source: '/rustc/library/core/src/cmp.rs', lines 248:0-248:39
   Name pattern: core::cmp::PartialEq -/
structure core.cmp.PartialEq (Self : Type) (Rhs : Type) where
  eq : Self → Rhs → Result Bool

/- Trait declaration: [core::cmp::Eq]
   Source: '/rustc/library/core/src/cmp.rs', lines 334:0-334:29
   Name pattern: core::cmp::Eq -/
structure core.cmp.Eq (Self : Type) where
  PartialEqInst : core.cmp.PartialEq Self Self

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::contains]:
   Source: 'src/lib.rs', lines 60:4-74:5 -/
divergent def BinTree.contains
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : BinTree T) (target : T) :
  Result Bool
  :=
  match self with
  | BinTree.Nil => Result.ok false
  | BinTree.Node value left right =>
    do
    let b ← corecmpEqInst.PartialEqInst.eq value target
    if b
    then Result.ok true
    else
      do
      let b1 ← BinTree.contains corecmpEqInst left target
      if b1
      then Result.ok true
      else BinTree.contains corecmpEqInst right target

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::reverse]:
   Source: 'src/lib.rs', lines 76:4-85:5 -/
divergent def BinTree.reverse
  {T : Type} (self : BinTree T) : Result (BinTree T) :=
  match self with
  | BinTree.Nil => Result.ok BinTree.Nil
  | BinTree.Node value left right =>
    do
    let left1 ← BinTree.reverse left
    let right1 ← BinTree.reverse right
    let (left2, right2) := core.mem.swap left1 right1
    Result.ok (BinTree.Node value left2 right2)

/- [testing_aeneas::BSTree]
   Source: 'src/lib.rs', lines 89:0-96:1 -/
inductive BSTree (T : Type) where
| Nil : BSTree T
| Node : T → BSTree T → BSTree T → BSTree T

/- [testing_aeneas::{testing_aeneas::BSTree<isize>}#2::contains]:
   Source: 'src/lib.rs', lines 99:4-111:5 -/
divergent def BSTreeIsize.contains
  (self : BSTree Isize) (target : Isize) : Result Bool :=
  match self with
  | BSTree.Nil => Result.ok false
  | BSTree.Node curr left right =>
    if target = curr
    then Result.ok true
    else
      if target < curr
      then BSTreeIsize.contains left target
      else BSTreeIsize.contains right target

/- [testing_aeneas::{testing_aeneas::BSTree<isize>}#2::insert]:
   Source: 'src/lib.rs', lines 112:4-130:5 -/
divergent def BSTreeIsize.insert
  (self : BSTree Isize) (value : Isize) : Result (BSTree Isize) :=
  match self with
  | BSTree.Nil =>
    let (_, self1) :=
      core.mem.replace BSTree.Nil (BSTree.Node value BSTree.Nil BSTree.Nil)
    Result.ok self1
  | BSTree.Node curr left right =>
    if value < curr
    then
      do
      let left1 ← BSTreeIsize.insert left value
      Result.ok (BSTree.Node curr left1 right)
    else
      if curr < value
      then
        do
        let right1 ← BSTreeIsize.insert right value
        Result.ok (BSTree.Node curr left right1)
      else Result.ok self

end testing_aeneas
