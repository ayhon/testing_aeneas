-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [testing_aeneas]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace testing_aeneas

/- [testing_aeneas::max]:
   Source: 'src/lib.rs', lines 5:0-7:1 -/
def max (a : I8) (b : I8) : Result I8 :=
  if a > b
  then ok a
  else ok b

/- [testing_aeneas::min]:
   Source: 'src/lib.rs', lines 8:0-10:1 -/
def min (a : I8) (b : I8) : Result I8 :=
  if a < b
  then ok a
  else ok b

/- [testing_aeneas::Tree]
   Source: 'src/lib.rs', lines 12:0-15:1 -/
inductive Tree (T : Type) where
| Leaf : T → Tree T
| Branch : Tree T → Tree T → Tree T

/- [testing_aeneas::{testing_aeneas::Tree<T>}::branch]:
   Source: 'src/lib.rs', lines 18:4-24:5 -/
def Tree.branch
  {T : Type} (left : Tree T) (right : Tree T) : Result (Tree T) :=
  ok (Tree.Branch left right)

/- [testing_aeneas::{testing_aeneas::Tree<T>}::rev]:
   Source: 'src/lib.rs', lines 26:4-31:5 -/
divergent def Tree.rev {T : Type} (self : Tree T) : Result (Tree T) :=
  match self with
  | Tree.Leaf _ => ok self
  | Tree.Branch left right =>
    do
    let t ← Tree.rev right
    let t1 ← Tree.rev left
    Tree.branch t t1

/- [testing_aeneas::{testing_aeneas::Tree<T>}::lenght]:
   Source: 'src/lib.rs', lines 33:4-38:5 -/
divergent def Tree.lenght {T : Type} (self : Tree T) : Result Usize :=
  match self with
  | Tree.Leaf _ => ok 1#usize
  | Tree.Branch left right =>
    do
    let i ← Tree.lenght left
    let i1 ← 1#usize + i
    let i2 ← Tree.lenght right
    i1 + i2

/- [testing_aeneas::BinTree]
   Source: 'src/lib.rs', lines 41:0-48:1 -/
inductive BinTree (T : Type) where
| Nil : BinTree T
| Node : T → BinTree T → BinTree T → BinTree T

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::nil]:
   Source: 'src/lib.rs', lines 52:4-52:49 -/
def BinTree.nil (T : Type) : Result (BinTree T) :=
  ok BinTree.Nil

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::insert]:
   Source: 'src/lib.rs', lines 53:4-63:5 -/
divergent def BinTree.insert
  {T : Type} (self : BinTree T) (value : T) : Result (BinTree T) :=
  match self with
  | BinTree.Nil => do
                   let bt ← BinTree.nil T
                   ok (BinTree.Node value bt bt)
  | BinTree.Node t bt right =>
    do
    let right1 ← BinTree.insert right value
    ok (BinTree.Node t bt right1)

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::size]:
   Source: 'src/lib.rs', lines 64:4-69:5 -/
divergent def BinTree.size {T : Type} (self : BinTree T) : Result U32 :=
  match self with
  | BinTree.Nil => ok 0#u32
  | BinTree.Node _ left right =>
    do
    let i ← BinTree.size left
    let i1 ← 1#u32 + i
    let i2 ← BinTree.size right
    i1 + i2

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::contains]:
   Source: 'src/lib.rs', lines 71:4-85:5 -/
divergent def BinTree.contains
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : BinTree T) (target : T) :
  Result Bool
  :=
  match self with
  | BinTree.Nil => ok false
  | BinTree.Node value left right =>
    do
    let b ← corecmpEqInst.partialEqInst.eq value target
    if b
    then ok true
    else
      do
      let b1 ← BinTree.contains corecmpEqInst left target
      if b1
      then ok true
      else BinTree.contains corecmpEqInst right target

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::reverse]:
   Source: 'src/lib.rs', lines 87:4-96:5 -/
divergent def BinTree.reverse
  {T : Type} (self : BinTree T) : Result (BinTree T) :=
  match self with
  | BinTree.Nil => ok BinTree.Nil
  | BinTree.Node t left right =>
    do
    let left1 ← BinTree.reverse left
    let right1 ← BinTree.reverse right
    let (left2, right2) := core.mem.swap left1 right1
    ok (BinTree.Node t left2 right2)

/- [testing_aeneas::BSTree]
   Source: 'src/lib.rs', lines 100:0-107:1 -/
inductive BSTree (T : Type) where
| Nil : BSTree T
| Node : T → BSTree T → BSTree T → BSTree T

/- [testing_aeneas::{testing_aeneas::BSTree<isize>}#2::contains]:
   Source: 'src/lib.rs', lines 110:4-122:5 -/
divergent def BSTreeIsize.contains
  (self : BSTree Isize) (target : Isize) : Result Bool :=
  match self with
  | BSTree.Nil => ok false
  | BSTree.Node curr left right =>
    if target = curr
    then ok true
    else
      if target < curr
      then BSTreeIsize.contains left target
      else BSTreeIsize.contains right target

/- [testing_aeneas::{testing_aeneas::BSTree<isize>}#2::insert]:
   Source: 'src/lib.rs', lines 123:4-141:5 -/
divergent def BSTreeIsize.insert
  (self : BSTree Isize) (value : Isize) : Result (BSTree Isize) :=
  match self with
  | BSTree.Nil =>
    let (_, self1) :=
      core.mem.replace BSTree.Nil (BSTree.Node value BSTree.Nil BSTree.Nil)
    ok self1
  | BSTree.Node curr left right =>
    if value < curr
    then
      do
      let left1 ← BSTreeIsize.insert left value
      ok (BSTree.Node curr left1 right)
    else
      if curr < value
      then
        do
        let right1 ← BSTreeIsize.insert right value
        ok (BSTree.Node curr left right1)
      else ok self

/- [testing_aeneas::AVLTree]
   Source: 'src/lib.rs', lines 144:0-152:1 -/
inductive AVLTree (T : Type) where
| Nil : AVLTree T
| Node : T → AVLTree T → AVLTree T → I8 → AVLTree T

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::contains]:
   Source: 'src/lib.rs', lines 155:4-168:5 -/
divergent def AVLTreeIsize.contains
  (self : AVLTree Isize) (target : Isize) : Result Bool :=
  match self with
  | AVLTree.Nil => ok false
  | AVLTree.Node value left right _ =>
    if target = value
    then ok true
    else
      if target < value
      then AVLTreeIsize.contains left target
      else AVLTreeIsize.contains right target

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rotateLeft]:
   Source: 'src/lib.rs', lines 171:4-214:5 -/
def AVLTreeIsize.rotateLeft (self : AVLTree Isize) : Result (AVLTree Isize) :=
  match self with
  | AVLTree.Nil => ok AVLTree.Nil
  | AVLTree.Node value_out left a bf_out =>
    match a with
    | AVLTree.Nil => ok self
    | AVLTree.Node value_in middle right bf_in =>
      do
      let i ← min bf_in 0#i8
      let i1 ← bf_out - i
      let bf_4 ← i1 + 1#i8
      let i2 ← 1#i8 + bf_in
      let i3 ← max bf_4 0#i8
      let bf_3 ← i2 + i3
      let a1 := AVLTree.Node value_out left middle bf_4
      ok (AVLTree.Node value_in a1 right bf_3)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rotateRight]:
   Source: 'src/lib.rs', lines 216:4-257:5 -/
def AVLTreeIsize.rotateRight (self : AVLTree Isize) : Result (AVLTree Isize) :=
  match self with
  | AVLTree.Nil => ok AVLTree.Nil
  | AVLTree.Node value_out a right bf_out =>
    match a with
    | AVLTree.Nil => ok self
    | AVLTree.Node value_in left middle bf_in =>
      do
      let i ← max bf_in 0#i8
      let i1 ← bf_out - i
      let bf_4 ← i1 - 1#i8
      let i2 ← min bf_4 0#i8
      let i3 ← bf_in + i2
      let bf_3 ← i3 - 1#i8
      let a1 := AVLTree.Node value_out middle right bf_4
      ok (AVLTree.Node value_in left a1 bf_3)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::balance_factor]:
   Source: 'src/lib.rs', lines 259:4-264:5 -/
def AVLTreeIsize.balance_factor (self : AVLTree Isize) : Result I8 :=
  match self with
  | AVLTree.Nil => ok 0#i8
  | AVLTree.Node _ _ _ bf => ok bf

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rebalance]:
   Source: 'src/lib.rs', lines 266:4-316:5 -/
def AVLTreeIsize.rebalance (self : AVLTree Isize) : Result (AVLTree Isize) :=
  match self with
  | AVLTree.Nil => ok AVLTree.Nil
  | AVLTree.Node value left right balance_factor =>
    if balance_factor = 2#i8
    then
      do
      let i ← AVLTreeIsize.balance_factor left
      if i = 1#i8
      then AVLTreeIsize.rotateRight (AVLTree.Node value left right 2#i8)
      else
        if i = (-1)#i8
        then
          do
          let a ← AVLTreeIsize.rotateLeft left
          AVLTreeIsize.rotateRight (AVLTree.Node value a right 2#i8)
        else ok self
    else
      if balance_factor = (-2)#i8
      then
        do
        let i ← AVLTreeIsize.balance_factor right
        if i = (-1)#i8
        then AVLTreeIsize.rotateLeft (AVLTree.Node value left right (-2)#i8)
        else
          if i = 1#i8
          then
            do
            let a ← AVLTreeIsize.rotateRight right
            AVLTreeIsize.rotateLeft (AVLTree.Node value left a (-2)#i8)
          else ok self
      else ok self

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rebalance_with_height_decrease]:
   Source: 'src/lib.rs', lines 318:4-372:5 -/
def AVLTreeIsize.rebalance_with_height_decrease
  (self : AVLTree Isize) : Result ((AVLTree Isize) × Bool) :=
  match self with
  | AVLTree.Nil => ok (AVLTree.Nil, false)
  | AVLTree.Node value left right balance_factor =>
    if balance_factor = 2#i8
    then
      do
      let child_balance_factor ← AVLTreeIsize.balance_factor left
      if child_balance_factor = (-1)#i8
      then
        do
        let a ← AVLTreeIsize.rotateLeft left
        let res ← AVLTreeIsize.rotateRight (AVLTree.Node value a right 2#i8)
        ok (res, true)
      else
        do
        let res ←
          AVLTreeIsize.rotateRight (AVLTree.Node value left right 2#i8)
        ok (res, child_balance_factor = 1#i8)
    else
      if balance_factor = (-2)#i8
      then
        do
        let child_balance_factor ← AVLTreeIsize.balance_factor right
        if child_balance_factor = 1#i8
        then
          do
          let a ← AVLTreeIsize.rotateRight right
          let res ←
            AVLTreeIsize.rotateLeft (AVLTree.Node value left a (-2)#i8)
          ok (res, true)
        else
          do
          let res ←
            AVLTreeIsize.rotateLeft (AVLTree.Node value left right (-2)#i8)
          ok (res, child_balance_factor = (-1)#i8)
      else ok (self, false)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::insertAndWarn]:
   Source: 'src/lib.rs', lines 374:4-403:5 -/
divergent def AVLTreeIsize.insertAndWarn
  (self : AVLTree Isize) (target : Isize) : Result ((AVLTree Isize) × Bool) :=
  match self with
  | AVLTree.Nil => ok (AVLTree.Node target AVLTree.Nil AVLTree.Nil 0#i8, true)
  | AVLTree.Node curr left right bf =>
    if target < curr
    then
      do
      let (left1, did_left_height_increase) ←
        AVLTreeIsize.insertAndWarn left target
      if did_left_height_increase
      then
        do
        let bf1 ← bf + 1#i8
        if bf1 = 2#i8
        then
          do
          let a ← AVLTreeIsize.rebalance (AVLTree.Node curr left1 right bf1)
          ok (a, false)
        else ok (AVLTree.Node curr left1 right bf1, bf = 0#i8)
      else
        if bf = 2#i8
        then
          do
          let a ← AVLTreeIsize.rebalance (AVLTree.Node curr left1 right bf)
          ok (a, false)
        else ok (AVLTree.Node curr left1 right bf, false)
    else
      if target > curr
      then
        do
        let (right1, did_right_height_increase) ←
          AVLTreeIsize.insertAndWarn right target
        if did_right_height_increase
        then
          do
          let bf1 ← bf - 1#i8
          if bf1 = (-2)#i8
          then
            do
            let a ←
              AVLTreeIsize.rebalance (AVLTree.Node curr left right1 bf1)
            ok (a, false)
          else ok (AVLTree.Node curr left right1 bf1, bf = 0#i8)
        else
          if bf = (-2)#i8
          then
            do
            let a ← AVLTreeIsize.rebalance (AVLTree.Node curr left right1 bf)
            ok (a, false)
          else ok (AVLTree.Node curr left right1 bf, false)
      else ok (self, false)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::insert]:
   Source: 'src/lib.rs', lines 405:4-407:5 -/
def AVLTreeIsize.insert
  (self : AVLTree Isize) (value : Isize) : Result (AVLTree Isize) :=
  do
  let (a, _) ← AVLTreeIsize.insertAndWarn self value
  ok a

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::updateLeftDeletion]:
   Source: 'src/lib.rs', lines 409:4-422:5 -/
def AVLTreeIsize.updateLeftDeletion
  (value : Isize) (did_left_height_decrease : Bool) (old_bf : I8)
  (left : AVLTree Isize) (right : AVLTree Isize) :
  Result ((AVLTree Isize) × Bool)
  :=
  if did_left_height_decrease
  then
    do
    let bf ← old_bf - 1#i8
    let (res, rebalance_height_decrease) ←
      AVLTreeIsize.rebalance_with_height_decrease (AVLTree.Node value left
        right bf)
    if bf = 0#i8
    then ok (res, true)
    else ok (res, rebalance_height_decrease)
  else
    AVLTreeIsize.rebalance_with_height_decrease (AVLTree.Node value left right
      old_bf)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::updateRightDeletion]:
   Source: 'src/lib.rs', lines 423:4-436:5 -/
def AVLTreeIsize.updateRightDeletion
  (value : Isize) (did_right_height_decrease : Bool) (old_bf : I8)
  (left : AVLTree Isize) (right : AVLTree Isize) :
  Result ((AVLTree Isize) × Bool)
  :=
  if did_right_height_decrease
  then
    do
    let bf ← old_bf + 1#i8
    let (res, rebalance_height_decrease) ←
      AVLTreeIsize.rebalance_with_height_decrease (AVLTree.Node value left
        right bf)
    if bf = 0#i8
    then ok (res, true)
    else ok (res, rebalance_height_decrease)
  else
    AVLTreeIsize.rebalance_with_height_decrease (AVLTree.Node value left right
      old_bf)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::popLeftmost]:
   Source: 'src/lib.rs', lines 439:4-451:5 -/
divergent def AVLTreeIsize.popLeftmost
  (self : AVLTree Isize) : Result ((AVLTree Isize) × Isize × Bool) :=
  match self with
  | AVLTree.Nil => ok (AVLTree.Nil, 0#isize, false)
  | AVLTree.Node popped a right bf =>
    match a with
    | AVLTree.Nil => ok (right, popped, true)
    | AVLTree.Node _ _ _ _ =>
      do
      let (left, popped1, did_left_height_decrease) ←
        AVLTreeIsize.popLeftmost a
      let (res, did_height_decrease) ←
        AVLTreeIsize.updateLeftDeletion popped did_left_height_decrease bf left
          right
      ok (res, popped1, did_height_decrease)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::deleteAndWarn]:
   Source: 'src/lib.rs', lines 453:4-476:5 -/
divergent def AVLTreeIsize.deleteAndWarn
  (self : AVLTree Isize) (target : Isize) : Result ((AVLTree Isize) × Bool) :=
  match self with
  | AVLTree.Nil => ok (AVLTree.Nil, false)
  | AVLTree.Node curr left right bf =>
    if target < curr
    then
      do
      let (left1, did_left_height_decrease) ←
        AVLTreeIsize.deleteAndWarn left target
      AVLTreeIsize.updateLeftDeletion curr did_left_height_decrease bf left1
        right
    else
      if target > curr
      then
        do
        let (right1, did_right_height_decrease) ←
          AVLTreeIsize.deleteAndWarn right target
        AVLTreeIsize.updateRightDeletion curr did_right_height_decrease bf left
          right1
      else
        if target = curr
        then
          match left with
          | AVLTree.Nil => ok (right, true)
          | AVLTree.Node i a a1 i1 =>
            match right with
            | AVLTree.Nil => ok (left, true)
            | AVLTree.Node _ _ _ _ =>
              do
              let (right1, popped, did_right_height_decrease) ←
                AVLTreeIsize.popLeftmost right
              let a2 := AVLTree.Node i a a1 i1
              AVLTreeIsize.updateRightDeletion popped did_right_height_decrease
                bf a2 right1
        else ok (self, false)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::delete]:
   Source: 'src/lib.rs', lines 477:4-479:5 -/
def AVLTreeIsize.delete
  (self : AVLTree Isize) (value : Isize) : Result (AVLTree Isize) :=
  do
  let (a, _) ← AVLTreeIsize.deleteAndWarn self value
  ok a

end testing_aeneas
