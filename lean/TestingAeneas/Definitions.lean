-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [testing_aeneas]
import Aeneas
open Aeneas.Std
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace testing_aeneas

/- [testing_aeneas::max]:
   Source: 'src/lib.rs', lines 4:0-6:1 -/
def max (a : I8) (b : I8) : Result I8 :=
  if a > b
  then Result.ok a
  else Result.ok b

/- [testing_aeneas::min]:
   Source: 'src/lib.rs', lines 7:0-9:1 -/
def min (a : I8) (b : I8) : Result I8 :=
  if a < b
  then Result.ok a
  else Result.ok b

/- [testing_aeneas::Tree]
   Source: 'src/lib.rs', lines 11:0-14:1 -/
inductive Tree (T : Type) where
| Leaf : T → Tree T
| Branch : Tree T → Tree T → Tree T

/- [testing_aeneas::{testing_aeneas::Tree<T>}::branch]:
   Source: 'src/lib.rs', lines 17:4-23:5 -/
def Tree.branch
  {T : Type} (left : Tree T) (right : Tree T) : Result (Tree T) :=
  Result.ok (Tree.Branch left right)

/- [testing_aeneas::{testing_aeneas::Tree<T>}::rev]:
   Source: 'src/lib.rs', lines 25:4-30:5 -/
divergent def Tree.rev {T : Type} (self : Tree T) : Result (Tree T) :=
  match self with
  | Tree.Leaf _ => Result.ok self
  | Tree.Branch left right =>
    do
    let t ← Tree.rev right
    let t1 ← Tree.rev left
    Tree.branch t t1

/- [testing_aeneas::{testing_aeneas::Tree<T>}::lenght]:
   Source: 'src/lib.rs', lines 32:4-37:5 -/
divergent def Tree.lenght {T : Type} (self : Tree T) : Result Usize :=
  match self with
  | Tree.Leaf _ => Result.ok 1#usize
  | Tree.Branch left right =>
    do
    let i ← Tree.lenght left
    let i1 ← 1#usize + i
    let i2 ← Tree.lenght right
    i1 + i2

/- [testing_aeneas::BinTree]
   Source: 'src/lib.rs', lines 40:0-47:1 -/
inductive BinTree (T : Type) where
| Nil : BinTree T
| Node : T → BinTree T → BinTree T → BinTree T

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::nil]:
   Source: 'src/lib.rs', lines 51:4-51:49 -/
def BinTree.nil (T : Type) : Result (BinTree T) :=
  Result.ok BinTree.Nil

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::insert]:
   Source: 'src/lib.rs', lines 52:4-62:5 -/
divergent def BinTree.insert
  {T : Type} (self : BinTree T) (value : T) : Result (BinTree T) :=
  match self with
  | BinTree.Nil =>
    do
    let bt ← BinTree.nil T
    Result.ok (BinTree.Node value bt bt)
  | BinTree.Node t bt right =>
    do
    let right1 ← BinTree.insert right value
    Result.ok (BinTree.Node t bt right1)

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::size]:
   Source: 'src/lib.rs', lines 63:4-68:5 -/
divergent def BinTree.size {T : Type} (self : BinTree T) : Result U32 :=
  match self with
  | BinTree.Nil => Result.ok 0#u32
  | BinTree.Node _ left right =>
    do
    let i ← BinTree.size left
    let i1 ← 1#u32 + i
    let i2 ← BinTree.size right
    i1 + i2

/- Trait declaration: [core::cmp::PartialEq]
   Source: '/rustc/library/core/src/cmp.rs', lines 248:0-248:39
   Name pattern: core::cmp::PartialEq -/
structure core.cmp.PartialEq (Self : Type) (Rhs : Type) where
  eq : Self → Rhs → Result Bool

/- Trait declaration: [core::cmp::Eq]
   Source: '/rustc/library/core/src/cmp.rs', lines 334:0-334:29
   Name pattern: core::cmp::Eq -/
structure core.cmp.Eq (Self : Type) where
  PartialEqInst : core.cmp.PartialEq Self Self

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::contains]:
   Source: 'src/lib.rs', lines 70:4-84:5 -/
divergent def BinTree.contains
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : BinTree T) (target : T) :
  Result Bool
  :=
  match self with
  | BinTree.Nil => Result.ok false
  | BinTree.Node value left right =>
    do
    let b ← corecmpEqInst.PartialEqInst.eq value target
    if b
    then Result.ok true
    else
      do
      let b1 ← BinTree.contains corecmpEqInst left target
      if b1
      then Result.ok true
      else BinTree.contains corecmpEqInst right target

/- [testing_aeneas::{testing_aeneas::BinTree<T>}#1::reverse]:
   Source: 'src/lib.rs', lines 86:4-95:5 -/
divergent def BinTree.reverse
  {T : Type} (self : BinTree T) : Result (BinTree T) :=
  match self with
  | BinTree.Nil => Result.ok BinTree.Nil
  | BinTree.Node t left right =>
    do
    let left1 ← BinTree.reverse left
    let right1 ← BinTree.reverse right
    let (left2, right2) := core.mem.swap left1 right1
    Result.ok (BinTree.Node t left2 right2)

/- [testing_aeneas::BSTree]
   Source: 'src/lib.rs', lines 99:0-106:1 -/
inductive BSTree (T : Type) where
| Nil : BSTree T
| Node : T → BSTree T → BSTree T → BSTree T

/- [testing_aeneas::{testing_aeneas::BSTree<isize>}#2::contains]:
   Source: 'src/lib.rs', lines 109:4-121:5 -/
divergent def BSTreeIsize.contains
  (self : BSTree Isize) (target : Isize) : Result Bool :=
  match self with
  | BSTree.Nil => Result.ok false
  | BSTree.Node curr left right =>
    if target = curr
    then Result.ok true
    else
      if target < curr
      then BSTreeIsize.contains left target
      else BSTreeIsize.contains right target

/- [testing_aeneas::{testing_aeneas::BSTree<isize>}#2::insert]:
   Source: 'src/lib.rs', lines 122:4-140:5 -/
divergent def BSTreeIsize.insert
  (self : BSTree Isize) (value : Isize) : Result (BSTree Isize) :=
  match self with
  | BSTree.Nil =>
    let (_, self1) :=
      core.mem.replace BSTree.Nil (BSTree.Node value BSTree.Nil BSTree.Nil)
    Result.ok self1
  | BSTree.Node curr left right =>
    if value < curr
    then
      do
      let left1 ← BSTreeIsize.insert left value
      Result.ok (BSTree.Node curr left1 right)
    else
      if curr < value
      then
        do
        let right1 ← BSTreeIsize.insert right value
        Result.ok (BSTree.Node curr left right1)
      else Result.ok self

/- [testing_aeneas::AVLTree]
   Source: 'src/lib.rs', lines 143:0-151:1 -/
inductive AVLTree (T : Type) where
| Nil : AVLTree T
| Node : T → AVLTree T → AVLTree T → I8 → AVLTree T

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::contains]:
   Source: 'src/lib.rs', lines 154:4-167:5 -/
divergent def AVLTreeIsize.contains
  (self : AVLTree Isize) (target : Isize) : Result Bool :=
  match self with
  | AVLTree.Nil => Result.ok false
  | AVLTree.Node value left right _ =>
    if target = value
    then Result.ok true
    else
      if target < value
      then AVLTreeIsize.contains left target
      else AVLTreeIsize.contains right target

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rotateLeft]:
   Source: 'src/lib.rs', lines 170:4-213:5 -/
def AVLTreeIsize.rotateLeft (self : AVLTree Isize) : Result (AVLTree Isize) :=
  match self with
  | AVLTree.Nil => Result.ok AVLTree.Nil
  | AVLTree.Node value_out left a bf_out =>
    match a with
    | AVLTree.Nil => Result.ok self
    | AVLTree.Node value_in middle right bf_in =>
      do
      let i ← min bf_in 0#i8
      let i1 ← bf_out - i
      let bf_4 ← i1 + 1#i8
      let i2 ← 1#i8 + bf_in
      let i3 ← max bf_4 0#i8
      let bf_3 ← i2 + i3
      let a1 := AVLTree.Node value_out left middle bf_4
      Result.ok (AVLTree.Node value_in a1 right bf_3)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rotateRight]:
   Source: 'src/lib.rs', lines 215:4-256:5 -/
def AVLTreeIsize.rotateRight (self : AVLTree Isize) : Result (AVLTree Isize) :=
  match self with
  | AVLTree.Nil => Result.ok AVLTree.Nil
  | AVLTree.Node value_out a right bf_out =>
    match a with
    | AVLTree.Nil => Result.ok self
    | AVLTree.Node value_in left middle bf_in =>
      do
      let i ← max bf_in 0#i8
      let i1 ← bf_out - i
      let bf_4 ← i1 - 1#i8
      let i2 ← min bf_4 0#i8
      let i3 ← bf_in + i2
      let bf_3 ← i3 - 1#i8
      let a1 := AVLTree.Node value_out middle right bf_4
      Result.ok (AVLTree.Node value_in left a1 bf_3)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::balance_factor]:
   Source: 'src/lib.rs', lines 258:4-263:5 -/
def AVLTreeIsize.balance_factor (self : AVLTree Isize) : Result I8 :=
  match self with
  | AVLTree.Nil => Result.ok 0#i8
  | AVLTree.Node _ _ _ bf => Result.ok bf

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::rebalance]:
   Source: 'src/lib.rs', lines 265:4-347:5 -/
def AVLTreeIsize.rebalance (self : AVLTree Isize) : Result (AVLTree Isize) :=
  match self with
  | AVLTree.Nil => Result.ok AVLTree.Nil
  | AVLTree.Node value left right balance_factor =>
    if balance_factor = 2#i8
    then
      do
      let i ← AVLTreeIsize.balance_factor left
      if i = 1#i8
      then AVLTreeIsize.rotateRight (AVLTree.Node value left right 2#i8)
      else
        if i = (-1)#i8
        then
          do
          let a ← AVLTreeIsize.rotateLeft left
          AVLTreeIsize.rotateRight (AVLTree.Node value a right 2#i8)
        else Result.ok self
    else
      if balance_factor = (-2)#i8
      then
        do
        let i ← AVLTreeIsize.balance_factor right
        if i = (-1)#i8
        then AVLTreeIsize.rotateLeft (AVLTree.Node value left right (-2)#i8)
        else
          if i = 1#i8
          then
            do
            let a ← AVLTreeIsize.rotateRight right
            AVLTreeIsize.rotateLeft (AVLTree.Node value left a (-2)#i8)
          else Result.ok self
      else Result.ok self

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::insertAndWarn]:
   Source: 'src/lib.rs', lines 349:4-383:5 -/
divergent def AVLTreeIsize.insertAndWarn
  (self : AVLTree Isize) (value : Isize) : Result ((AVLTree Isize) × Bool) :=
  match self with
  | AVLTree.Nil =>
    Result.ok (AVLTree.Node value AVLTree.Nil AVLTree.Nil 0#i8, false)
  | AVLTree.Node curr left right bf =>
    if value != curr
    then
      if value < curr
      then
        do
        let p ← AVLTreeIsize.insertAndWarn left value
        let (res, did_height_increase) := p
        if did_height_increase
        then
          do
          let bf1 ← bf + 1#i8
          if bf1 = 2#i8
          then do
               let a ← AVLTreeIsize.rebalance res
               Result.ok (a, false)
          else Result.ok p
        else Result.ok p
      else
        do
        let p ← AVLTreeIsize.insertAndWarn right value
        let (res, did_height_increase) := p
        if did_height_increase
        then
          do
          let bf1 ← bf - 1#i8
          if bf1 = (-2)#i8
          then do
               let a ← AVLTreeIsize.rebalance res
               Result.ok (a, false)
          else Result.ok p
        else Result.ok p
    else Result.ok (self, false)

/- [testing_aeneas::{testing_aeneas::AVLTree<isize>}#3::insert]:
   Source: 'src/lib.rs', lines 385:4-387:5 -/
def AVLTreeIsize.insert
  (self : AVLTree Isize) (value : Isize) : Result (AVLTree Isize) :=
  do
  let p ← AVLTreeIsize.insertAndWarn self value
  let (a, _) := p
  Result.ok a

end testing_aeneas
